#!/usr/bin/env python
import fileinput
import sys
#see: https://www.tutorialspoint.com/python/python_xml_processing.htm
import xml.sax
intTy = "$INT"
polymorphic = []
simple = []
unsorted = []
prefix = []
postfix = []

#parsing args
argnum = len(sys.argv)
if argnum  == 1:
    pass
elif argnum == 2:
    arg1 = sys.argv[1]
    pass
else:
    print "wrong number of arguments: " + str(argnum)
    sys.exit()

# see: https://interactivepython.org/runestone/static/pythonds/BasicDS/ImplementingaStackinPython.html
class stack:
     def __init__(self):
         self.items = []
     def isEmpty(self):
         return self.items == []
     def push(self, item):
         self.items.append(item)
     def pop(self):
         return self.items.pop()
     def top(self):
         return self.items[len(self.items)-1]
     def size(self):
         return len(self.items)

tagStack = stack()

# parser

class FunctionHandler (xml.sax.ContentHandler):
    def __init__(self):
        key = ""

    def startElement(self, tag, atts):
        tagStack.push(tag)
        if tag == "func":
            self.name = atts["name"].strip()
        elif tag == "collection":
            self.key = atts["type"].strip()
            
    def endElement(self, tag):
        if tag == "func":
            global polymorphic
            global simple
            global unsorted
            func = (self.name, self.header)
            if self.key == "polymorphic":
                polymorphic.append(func)
            elif self.key == "simple":
                simple.append(func)
            else:
                unsorted.append(func)
        tagStack.pop()
            
    def characters(self, str):
        global prefix
        global postfix
        if tagStack.top() == "prefix":
            prefix.append(str.strip())
        elif tagStack.top() == "postfix":
            postfix.append(str.strip())
        elif tagStack.top() == "header":
            self.header = str.strip()
    
parser = xml.sax.make_parser()
parser.setFeature(xml.sax.handler.feature_namespaces,0)
handler = FunctionHandler()
parser.setContentHandler(handler)

parser.parse(sys.stdin)

# generator

header = open('c-driver.hpp', 'w')
source = open('c-driver.cpp', 'w')

print "// Attention: this file is automatically generated, do not change it manually!"

def printlist(f, l):
    for s in l:
        f.write(s.strip() + "\n")

printlist(header, prefix)

def printpoly(f, header):
    for i in ["i8", "i16", "i32", "i64"]:
        f.write( "\t" + header.replace("$INT", i) + ";" + "\n")

def printsimple(f, header):
    f.write( "\t" + header + ";" + "\n" )

def printCollection(f, title, collection, printer):
    f.write( "\t// " + title + "\n")
    for func in collection:
        name = func[0]
        header = func[1]
        final = header.replace("$NAME", name)
        f.write("\t//" + name + "\n")
        printer(f, final)

printCollection(header, "POLYMORPHIC", polymorphic, printpoly)
printCollection(header, "SIMPLE", simple, printsimple)

printlist(header, postfix)
